{"name":"KAI","tagline":"DHT storage by Takeshi Inoue","body":"KAI\r\n===\r\n\r\nKai is a distributed key-value datastore, which is mainly inspired\r\nby Amazon's Dynamo. It brings high scalability and availability\r\nto your Web sites. You can manage variety of contents with Kai,\r\nas if Amazon's Dynamo stores shopping carts, catalogs, session states,\r\nand so forth. Currently, Kai is deployed in a commercial service,\r\nhttp://home.goo.ne.jp, which is a Japanese social networking service of more\r\nthan 10 million users.\r\n\r\nFeatures\r\n--------\r\n\r\n* 16 nodes\r\n* 2 GB/node, on memory\r\n* 1,000 qps for whole system\r\n* < 300ms for requests of 99%\r\n* Fairly balancing loads\r\n* Consitent hashing, nodes, buckets\r\n* Secondary Indexes\r\n* Storage Backends: ETS, DETS\r\n* Quorum coordinator\r\n* Sync data one by another\r\n* Gossip-based protocol membership\r\n* Memcache Interface\r\n\r\nGoal\r\n------\r\n\r\n* 256 nodes\r\n* 32 GB/node\r\n* 100,000 qps for whole system\r\n* Physical placement\r\n* Merkle Tree sync\r\n* Chord or Kademlia membeship\r\n\r\nStandalone Mode\r\n---------------\r\n\r\nFor practice, we begin with a stand-alone server, not clustered system.\r\nThe stand-alone Kai is not attractive, because it has no reliability\r\n(no replication). The behavior is, however, quite similar with that\r\nof well-known memcached, and so this can be a good starting point.\r\nBefore running Kai, stop a memcached if runnnig, because Kai uses\r\nthe same port number (11211) by default. Set parameters \"n\", \"r\",\r\nand \"w\" to 1 in the configuration file \"sys.config\"; other parameters\r\nremain in default (Details for the parameters are described in Configuration).\r\n\r\n    [{kai, [\r\n        {logfile, \"kai.log\"},\r\n        {hostname, \"localhost\"},\r\n        {rpc_port, 11011},\r\n        {rpc_max_processes, 30},\r\n        {memcache_port, 11211},\r\n        {memcache_max_processes, 10},\r\n        {max_connections, 32},\r\n        {n, 1},\r\n        {r, 1},\r\n        {w, 1},\r\n        {number_of_buckets, 1024},\r\n        {number_of_virtual_nodes, 128},\r\n        {store, ets},\r\n        {dets_dir, \"/path/to/dir\"},\r\n        {number_of_tables, 256}]}].\r\n\r\nCluster Mode\r\n------------\r\n\r\nThis section describes how to run multiple Kai nodes as a clustered system.\r\nWhile we will run all nodes on a single physical machine for convenience,\r\nthe cluster can be consisted of different machines just by changing IP\r\naddresses and port numbers in the following example. In this example,\r\nwe run four distinct nodes on a single physical machine. Copy the\r\nconfiguration file for them. They are named \"kai1.config\" to \"kai4.config\";\r\na node configured by kai1.config is called Node1, hereafter.\r\nTo replicate data, set the quorum parameter \"n\" to the degree of replication.\r\nIn this example, we set \"n\" to 3 in the configuration file \"kai.config\".\r\nOther quorum parameters \"r\" and \"w\" is set in according to the quorum conditions.\r\n\r\n\r\n| Name | Value |\r\n|------|-------|\r\n| n    |     3 |\r\n| r    |     2 |\r\n| w    |     2 |\r\n\r\nHosts config:\r\n\r\n| Node1         | Value |\r\n|---------------|-------|\r\n| rpc_port      | 11011 |\r\n| memcache_port | 11211 |\r\n\r\n| Node2         | Value |\r\n|---------------|-------|\r\n| rpc_port      | 11012 |\r\n| memcache_port | 11212 |\r\n\r\n| Node3         | Value |\r\n|---------------|-------|\r\n| rpc_port      | 11013 |\r\n| memcache_port | 11213 |\r\n\r\n| Node4         | Value |\r\n|---------------|-------|\r\n| rpc_port      | 11014 |\r\n| memcache_port | 11214 |\r\n\r\nStaring Node1:\r\n\r\n    % erl -pa ebin -config kai1\r\n    > application:start(kai).\r\n\r\nTo make a cluster, start Node2 and add it to the cluster (that includes only\r\nNode1 currently) by informing of their neighbors with function \"kai_rpc:check_node/2\".\r\n\r\n    % erl -pa ebin -config kai2\r\n    > application:start(kai).\r\n    > kai_rpc:check_node({{127,0,0,1}, 11012}, {{127,0,0,1}, 11011}).\r\n    > kai_rpc:check_node({{127,0,0,1}, 11011}, {{127,0,0,1}, 11012}).\r\n\r\nWe give a brief explanation this process. A Kai node maintains a node list\r\nincluding members of the cluster it belongs to. In the initial state, each\r\nnode list includes only the node itself. By issuing function \"kai_rpc:check_node/2\",\r\na node of the first argument retrieves a node list from another node of\r\nthe second argument, and merge the list with that of itself. By calling\r\nthis function twice, a new node can be added to the cluster; inform a\r\nnew node of any cluster node by the first call, and vice versa (wait\r\nfor finishing data synchronization if some data have already been\r\nstored in the cluster).\r\n\r\nIn this example, Node2 (127.0.0.1:11012) gets a node list of\r\nNode1 (127.0.0.1:11011) by the first \"kai_rpc:check_node/2\"; Node2 \r\nknows Node1. The second RPC informs Node1 of Node2.\r\n\r\nHere, make sure Node1 and Node2 know each other.\r\n\r\n    > kai_rpc:node_list({{127,0,0,1}, 11011}).\r\n    {node_list,[{{127,0,0,1},11011},\r\n            {{127,0,0,1},11012}]}\r\n\r\n    > kai_rpc:node_list({{127,0,0,1}, 11012}).\r\n    {node_list,[{{127,0,0,1},11011},\r\n            {{127,0,0,1},11012}]}\r\n\r\nIn the same manner, add Node3 to the cluster.\r\n\r\n    % erl -pa ebin -config kai3\r\n    > application:start(kai).\r\n    > kai_rpc:check_node({{127,0,0,1}, 11013}, {{127,0,0,1}, 11011}).\r\n    > kai_rpc:check_node({{127,0,0,1}, 11011}, {{127,0,0,1}, 11013}).\r\n\r\nBy the third \"kai_rpc:check_node/2\", Node3 gets a node list of Node1,\r\nwhich includes Node2 as well as Node1. The fourth \"kai_rpc:check_node/2\"\r\ninforms Node1 of Node3. Now, while Node1 and Node3 know all the three\r\nnodes, Node2 does not know Node3 yet. Node2, however, gets to know\r\nNode3 eventually, because each node periodically exchanges its node\r\nlist to a node randomly chosen among the node list. Every node,\r\nfinally, knows each other, and makes the cluster of the three nodes.\r\nFinally, add Node4 to the cluster.\r\n\r\n    % erl -pa ebin -config kai4\r\n    > application:start(kai).\r\n    > kai_rpc:check_node({{127,0,0,1}, 11014}, {{127,0,0,1}, 11011}).\r\n    > kai_rpc:check_node({{127,0,0,1}, 11011}, {{127,0,0,1}, 11014}).\r\n\r\nWe make sure whether each node knows all by function \"kai_rpc:node_list/1\".\r\nIf the cluster is correctly made up, the output includes the four nodes like this.\r\n\r\n    > kai_rpc:node_list({{127,0,0,1}, 11011}).\r\n    {node_list,[{{127,0,0,1},11011},\r\n            {{127,0,0,1},11012},\r\n            {{127,0,0,1},11013},\r\n            {{127,0,0,1},11014}]}\r\n\r\nTo remove a node, no procedure is needed. This implies that no\r\naction is needed when a node is accidentally going down. However,\r\nit's better to remove a node one by one; don't remove more than or\r\nequal to N nodes before finishing data synchronization.\r\n\r\nStatistics\r\n----------\r\n\r\nStatistics for the Kai node can be retrieved by issuing stats\r\ncommand of memcache APIs. The parameters without \"kai_\" or \"erlang_\" prefix\r\nare in common with memcache APIs. Some of Kai related parameters are\r\nexplained in Configuration in detail.\r\n\r\n| Name             |  Description                                                            |\r\n|------------------|-------------------------------------------------------------------------|\r\n| uptime           | Number of seconds this server has been running. |\r\n| time             | Current UNIX time according to the server. |\r\n| version          | Version string of the Kai node. |\r\n| bytes            | Current number of bytes used by the Kai node to store items. |\r\n| curr_items       | Current number of items stored by the Kai node. |\r\n| curr_connections | Number of open connections. |\r\n| cmd_get          | Successful retrieval requests processed by the Kai node. |\r\n| cmd_set          | Successful storage requests processed by the Kai node. |\r\n| bytes_read       | Total number of bytes transferred from the Kai node. |\r\n| bytes_write      | Total number of bytes transferred to the Kai node. |\r\n| kai_node         | Socket address for internal RPC in the Kai node. |\r\n| kai_quorum       | Parameters for the quorum protocol; i.e. N:R:W. |\r\n| kai_buckets      | Number of buckets in the Kai cluster. |\r\n| kai_vnodes       | Number of virtual nodes in the Kai node.  |\r\n| kai_store        | Storage type used by the Kai node; ets or dets.  |\r\n| kai_curr_nodes   | Membership in the current cluster. |\r\n| kai_unreconciled | Cumulative number of retrieval requests with confliction. |\r\n| erlang_procs     | Number of Erlang processes. |\r\n| erlang_version   | Version string of Erlang. |\r\n\r\nSome statistics (bytes, curr_items, cmd_get, cmd_set, bytes_read, and bytes_write) can be\r\ndrawn by Cacti, which is a complete network graphing solution designed to harness the power\r\nof RRDTool's data storage and graphing functionality.\r\n\r\n![Cacti](http://sourceforge.net/apps/mediawiki/kai/nfs/project/k/ka/kai/8/8d/Deployment_01.png)\r\n\r\nCredits\r\n-------\r\n\r\n* Takeshi Inoue\r\n* Maxim Sokhatsky\r\n\r\nOM A HUM\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}